# 缓存

> 本文档中部分代码不保证可以运行

虽然标题为缓存，但在这里不仅仅会涉及缓存，还会涉及一些其他提高应用性能的方案。

在程序设计中，经常能听到的就是`以时间换空间`和`以空间换时间`。`缓存`作为一种能加快程序性能的银弹，它是典型的后者(`以空间换时间`).

随着互联网的普及，内容信息越来越复杂，用户数和访问量越来越大，我们的应用需要支撑更多的并发量，同时我们的应用服务器和数据库服务器所做的计算也越来越多。但是往往我们的应用服务器资源是有限的，且技术变革是缓慢的，数据库每秒能接受的请求次数也是有限的（或者文件的读写也是有限的），如何能够有效利用有限的资源来提供尽可能大的吞吐量？一个有效的办法就是引入缓存，打破标准流程，每个环节中请求可以从缓存中直接获取目标数据并返回，从而减少计算量，有效提升响应速度，让有限的资源服务更多的用户。

# 第一次接触缓存`MAP`

我第一次接触缓存的时候是在大三开始出去工作的时候。在一个系统中，基本每个接口都有可能要获取一次用户信息和一些用户配置，当时我们的系统查多改少，这也注定缓存可以大大提高我们的性能，当时的做法是维护一个全局的单例的`Map`作为缓存存储.记得当时的类名叫`DBMirror`

大致如下：
```java
class DBMirror {
    private static Map<String, User> userCache = new HashMap<>();

    public static void putUser(String key, User user) {
        userCache.put(key, user);
    }

    public static User getUser(String key) {
        return userCache.get(key);
    } 

    private DBMirror() {}

}
```

代码很简单，基本满足了当时系统的要求，减少了很多数据库读写操作，在当时也是第一次开始意识到`数据库`并不是唯一的存储

但是上面的代码有个很大的缺点，随着用户的增多，里面并没有合适的剔除算法，会导致`Map`越来越大，极端情况会导致内存溢出

# 常见淘汰策略

如上所述，如果不使用剔除算法，会导致内存占用越来越大，且无法回收，那下面讲一下常见的淘汰策略

## FIFO(first in first out)
先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。

## LFU(less frequently used)
最少使用策略，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。

## LRU(least recently used)
最近使用策略，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。

## 其他
1. 为缓存元素设置过期时间，清理超过过时时间的元素
1. 随机清理
1. 优先清理大对象

# 缓存简单分类

**本地缓存**：指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。

**分布式缓存**：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。缺点是：优点也就是缺点，因为自身是一个独立的应用，本地节点都需要与其进行通信，导致依赖网络，同时如果缓存服务崩溃可能会影响所有依赖节点

> 技术方案本身没有最好的，只有最合适的.

# 缓存的使用

## Java集合类

在上面提供了一个简单的例子，`DBMirror`使用`Map`来时间一个简单的内存缓存，同时`Set`、`List`都可以达到内存缓存的功能，根据并发情况可以选择不同的实现类,例如`HashMap`、`LinkedHashMap`、`TreeMap`、`LinkedTreeMap`、`ConcurrentHashMap`... 总有一个满足你

这样实现很简单，但是也致命缺点：无法回收不常用的缓存

## guava cache

Guava 是google开源的一个java工具类，其中包含对cache的实现，同时自带了缓存管理机制

## Ehcache

Ehcache是纯Java开源缓存框架，配置简单、结构清晰、功能强大，是一个非常轻量级的缓存实现，我们常用的Hibernate里面就集成了相关缓存功能。

## memcached

## redis

# Spring Cache




# 





# 参考
1. spring cache
2. `guava https://github.com/google/guava/wiki/CachesExplained`






Ehcache

![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/b810d158.png)


Ehcache的配置使用如下：

<ehcache>
<!-- 指定一个文件目录，当Ehcache把数据写到硬盘上时，将把数据写到这个文件目录下 -->
<diskStore path="java.io.tmpdir"/>

<!-- 设定缓存的默认数据过期策略 -->
<defaultCache
        maxElementsInMemory="10000"
        eternal="false"
        overflowToDisk="true"
        timeToIdleSeconds="0"
        timeToLiveSeconds="0"
        diskPersistent="false"
        diskExpiryThreadIntervalSeconds="120"/>

<!--  
    设定具体的命名缓存的数据过期策略

    cache元素的属性：
        name：缓存名称

        maxElementsInMemory：内存中最大缓存对象数

        maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大

        eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false

        overflowToDisk：true表示当内存缓存的对象数目达到了maxElementsInMemory界限后，会把溢出的对象写到硬盘缓存中。注意：如果缓存的对象要写入到硬盘中的话，则该对象必须实现了Serializable接口才行。

        diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。

        diskPersistent：是否缓存虚拟机重启期数据

        diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认为120秒

        timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地处于空闲状态

        timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，Ehcache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义

        memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
-->
<cache name="CACHE1"
       maxElementsInMemory="1000"
       eternal="true"
       overflowToDisk="true"/>  

<cache name="CACHE2"
    maxElementsInMemory="1000"
    eternal="false"
    timeToIdleSeconds="200"
    timeToLiveSeconds="4000"
    overflowToDisk="true"/>
</ehcache>
整体上看，Ehcache的使用还是相对简单便捷的，提供了完整的各类API接口。需要注意的是，虽然Ehcache支持磁盘的持久化，但是由于存在两级缓存介质，在一级内存中的缓存，如果没有主动的刷入磁盘持久化的话，在应用异常down机等情形下，依然会出现缓存数据丢失，为此可以根据需要将缓存刷到磁盘，将缓存条目刷到磁盘的操作可以通过cache.flush()方法来执行，需要注意的是，对于对象的磁盘写入，前提是要将对象进行序列化。

主要特性：

快速，针对大型高并发系统场景，Ehcache的多线程机制有相应的优化改善。
简单，很小的jar包，简单配置就可直接使用，单机场景下无需过多的其他服务依赖。
支持多种的缓存策略，灵活。
缓存数据有两级：内存和磁盘，与一般的本地内存缓存相比，有了磁盘的存储空间，将可以支持更大量的数据缓存需求。
具有缓存和缓存管理器的侦听接口，能更简单方便的进行缓存实例的监控管理。
支持多缓存管理器实例，以及一个实例的多个缓存区域。
注意：Ehcache的超时设置主要是针对整个cache实例设置整体的超时策略，而没有较好的处理针对单独的key的个性的超时设置（有策略设置，但是比较复杂，就不描述了），因此，在使用中要注意过期失效的缓存元素无法被GC回收，时间越长缓存越多，内存占用也就越大，内存泄露的概率也越大。




